- [Related CPU registers](#related-cpu-registers)
  - [Configurations](#configurations)
  - [Trap flow control related](#trap-flow-control-related)
- [Handling trap](#handling-trap)
  - [Trap handling example](#trap-handling-example)
- [Reference](#reference)

# Related CPU registers
## Configurations
- SCR_EL3
  - Support only EL3 is implemented
  - Configure security status
  - Control IRQ, FIQ should be routed to EL3 or not
- HCR_EL2
  - Support only EL2 is implemented
  - Configure for virtualization
  - Control IRQ, FIQ should be routed to EL2 or not
- SPSR
  - Saved process state (DAFI, NZCV, etc. flags)
  - 7 different SPSR
    - EL1
    - EL2
    - EL3
    - abt
    - fiq
    - irq
    - und
- SPSel
  - Stack pointer select
  - If set to 1, use SP_ELx for ELx
  - Otherwise, use SP_EL0 for ELx
- SCTLR_ELx
  - Top level system control
- VBAR_ELx
  - Exception vector table base address
  - The exception vector table base address must be aligned to 2k
- NZCV
- DAIF

## Trap flow control related
- ELR_ELx
  - Hold the return address for the exception to return to
- FAT_ELx
  - Hold the faulting virtual address for synchoronous instructions
- ESR_ELx
  - Hold the exception reason
- SP_ELx
  - stack pointer for ELx
- CurrentEL
  - Hold current exception level value

# Handling trap
1. If a trap needs to be handled in a specific EL.
   1. VBAR_ELx must be configured
      1. A trap vector table base address must be aligned to 2k
      2. Each trap vector can only contain 128 bytes instructions -> 32 instructions
   2. SCR_EL3 must set EA, IRQ, FIQ if interrupts, exceptions want to be handled in EL3
   3. HCR_EL2 must set AMO, IMO, FMO if interrupts, exceptions want to be handled in EL2
   4. DAIF flags must be unmask to let the CPU allow to receive exceptions and interrupts
2. Hardware will 
   1. Automatically backup return address to ELR and CPSR to SPSR
   2. Setup ESR, FAR if an exception happened
   3. Jump to the configured EL according to the interrupt, exception routing rule configured by SCR_EL3, HCR_EL2
3. Bare metal part of the trap handler must backup the context that is interrupted or suspended by the exception.
   1. The bare metal part of the trap handler in Armv8 are divided to 4 parts and each part should be aligned to 512B boundary
      1. The trap handling EL is using SP_EL0 as its SP
      2. The trap handling EL is using SP_ELx as its SP
      3. The trap is happened from lower EL in aarch64
      4. The trap is happened from lower EL in aarch32
   2. Each part can further be divided to 4 blocks and each block should be aligned to 128B boundary
      1. Synchronize exception
         - MMU related, page fault
         - Invalid instructions (ex. using NEON instructions before enabling it)
         - SVC, HVC, SMC related trap instructions
         - Usually, ELR is set to the address of the current instruction
           - For example, when CPU trying to read an address that is not yet mapped in MMU
      2. Interrupt
         - It is asynchronized and usually can be happened at any time
         - ELR is usually set to the next instruction of the instruction that is interrupted since CPU will start to backup enough hardware information after the current instruction is interrupted
      3. FIQ (Fast interrupt)
         - It is the same as interrupt but it just have higher priority
      4. Serror
         - System Error (SError) is an exception type that is intended to be generated by the memory system in response to unexpected events. We do not expect these events, but need to know if they have occurred.
4. Jump to interrupt or exception handler to deal with traps
5. Restore the context and potentially modify ELR to return to normal mode with correct return address

## Trap handling example
In the example, I will demonstrate in EL1 only and using SP_EL1 for EL1
1. Setup SPSel
   ```C
   mrs	        x10, spsel
   orr	        x10, x10, #1
   msr	        spsel, x10
   ```
2. Implement trap handler. Right now just using the second part of the trap vector as demonstration which is using SP_ELx for handling ELx's trap. For the others, just put them to spin forever to catch the error in case we mistakenly configured something
   1. Trap handler for sync, irq, fiq, serror. This assembly function will eventually call to el\${x}\_\${ht}\_\${regsize}\_\${label}\_handler C function, where x is EL level, ht is corresponding the handler is using SP_ELx or SP_EL0, regsize is corresponding the context is aarch64 or aarch32, label is either sync, irq, fiq or serror. For example, el1h_64_irq is the handler to deal with the interrupt happened during aarch64 and using SP_ELx in EL1 and it will call to el1h_64_irq_handler after the context is backuped.
      ```C
      .macro trap_handler el:req, ht:req, regsize:req, label:req
         .text
        .align 3
      el\el\ht\()_\regsize\()_\label:
      	/* preserve space to backup context registers */
      	sub		sp, sp, #CTX_REG_SZ

      	/* backup x10, x11 first before using them */
      	/* TODO: should check if stack overflow happened */
      	stp		x10, x11, [sp, #-32]!

      	/* load stack address offset to save the context */
      	mov		x10, sp
      	add		x10, x10, #32
      	reg_backup	x10

      	/* load original x10, x11 and backup them */
      	ldp		x12, x13, [sp], #32
      	stp		x12, x13, [x10, #TASK_CTX_X10]
      	mov		x12, sp
      	str		x12, [x10, #TASK_CTX_SP]

      	/*
      	 * call to trap handler in C environment
      	 * The handler itself should update elr if needed
      	*/
      	bl		el\el\ht\()_\regsize\()_\label\()_handler

      	/* restore context */
      	mov		x10, sp
      	reg_restore	x10

      	/* free backup context registers space */
      	add		sp, sp, #CTX_REG_SZ

      	/* return to normal mode */
      	eret
      .endm

      	trap_handler	1, h, 64, sync
      	trap_handler	1, h, 64, irq
      	trap_handler	1, h, 64, fiq
      	trap_handler	1, h, 64, serror

      hang:
      	b hang
      ```
   2. context backup routine
      ```C
      /* explicitly not saving x10, x11 since they're corrupted right now */
      .macro reg_backup base
      	stp		x0, x1, [\base, #TASK_CTX_X0]
        stp		x2, x3, [\base, #TASK_CTX_X2]
      	stp		x4, x5, [\base, #TASK_CTX_X4]
      	stp		x6, x7, [\base, #TASK_CTX_X6]
      	stp		x8, x9, [\base, #TASK_CTX_X8]
      	stp		x12, x13, [\base, #TASK_CTX_X12]
      	stp		x14, x15, [\base, #TASK_CTX_X14]
      	stp		x16, x17, [\base, #TASK_CTX_X16]
      	stp		x18, x19, [\base, #TASK_CTX_X18]
      	stp		x20, x21, [\base, #TASK_CTX_X20]
      	stp		x22, x23, [\base, #TASK_CTX_X22]
      	stp		x24, x25, [\base, #TASK_CTX_X24]
      	stp		x26, x27, [\base, #TASK_CTX_X26]
      	stp		x28, x29, [\base, #TASK_CTX_X28]
      	str		x30, [\base, #TASK_CTX_LR]
      .endm
      
      .macro reg_restore base
      	ldp		x30, x12, [\base, #TASK_CTX_LR]
      	mov		sp, x12
      	ldp		x0, x1, [\base, #TASK_CTX_X0]
      	ldp		x2, x3, [\base, #TASK_CTX_X2]
      	ldp		x4, x5, [\base, #TASK_CTX_X4]
      	ldp		x6, x7, [\base, #TASK_CTX_X6]
      	ldp		x8, x9, [\base, #TASK_CTX_X8]
      	ldp		x12, x13, [\base, #TASK_CTX_X12]
      	ldp		x14, x15, [\base, #TASK_CTX_X14]
      	ldp		x16, x17, [\base, #TASK_CTX_X16]
      	ldp		x18, x19, [\base, #TASK_CTX_X18]
      	ldp		x20, x21, [\base, #TASK_CTX_X20]
      	ldp		x22, x23, [\base, #TASK_CTX_X22]
      	ldp		x24, x25, [\base, #TASK_CTX_X24]
      	ldp		x26, x27, [\base, #TASK_CTX_X26]
      	ldp		x28, x29, [\base, #TASK_CTX_X28]
      	ldp		x10, x11, [\base, #TASK_CTX_X10]
      .endm
      ```
   3. Place the handler according to the specification
      ```C
      trap_vector:
      	/* trap from current EL with SP_EL0 */
      	.align 7	/* synchronous */
      	b hang
      	.align 7	/* IRQ */
      	b hang
      	.align 7	/* FIQ */
      	b hang
      	.align 7	/* SError */
      	b hang
      	/* trap from current EL with SP_ELx */
      	.align 7	/* synchronous */
      	b el1h_64_sync
      	.align 7	/* IRQ */
      	b el1h_64_irq
      	.align 7	/* FIQ */
      	b el1h_64_fiq
      	.align 7	/* SError */
      	b el1h_64_serror
      	/* trap from lower EL with AArch64 */
      	.align 7	/* synchronous */
      	b hang
      	.align 7	/* IRQ */
      	b hang
      	.align 7	/* FIQ */
      	b hang
      	.align 7	/* SError */
      	b hang
      	/* trap from lower EL with AArch32 */
      	.align 7	/* synchronous */
      	b hang
      	.align 7	/* IRQ */
      	b hang
      	.align 7	/* FIQ */
      	b hang
      	.align 7	/* SError */
      	b hang
      ```
   4. Setup trap handler vector base address
      ```C
        ldr	        x10, =trap_vector
        msr	        vbar_el1, x10
      ```
3. After above setting is well programed, the rest to do is just implementing el\${x}\_\${ht}\_\${regsize}\_\${label}\_handler. If it is going to handle IRQ, el1h_64_irq_handler must be implemented and usually GIC driver should be the next essential component to deal with the interrupt.

# Reference
https://developer.arm.com/documentation/ddi0601/2024-12
https://developer.arm.com/documentation/102412/0103
https://krinkinmu.github.io/2021/01/10/aarch64-interrupt-handling.html
https://blog.csdn.net/qq_38131812/article/details/130141118
https://blog.csdn.net/sinat_32960911/article/details/127856639